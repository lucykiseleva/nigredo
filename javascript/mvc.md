
# Шаблоны проектирования

[Паттерны для масштабируемых JavaScript-приложений](http://largescalejs.ru)


## Литеральная нотация объектов (Object)

В литеральной нотации объект описывается внутри блока фигурных скобок (`{}`), как набор разделенных запятой пар ключ/значение. Ключи объекта могут быть как строками, так и идентификаторами. После имени ставится двоеточие. В объекте не должно стоять запятой после последней пары ключ/значение, так как это может привести к ошибкам.

Литерал объекта не требует использования оператора new для создания экземпляра, но он не должен стоять в начале выражения, так как открытая {может быть воспринята как начало блока. Ниже вы можете увидеть пример модуля, определенного с помощью литеральной нотации объекта. Новые члены объекта могут быть добавлены с помощью конструкции `myModule.property = 'someValue';`

Паттерн «модуль» может быть полезен для многих вещей. Но если вы считаете, что вам не нужно делать приватными некоторые методы или свойства, то литерал объекта — более чем подходящий выбор.

````javascript 
var myModule = {
  myProperty: 'someValue',
  // Литералы объектов могут содержать свойства и методы. 

  // ниже в свойстве определен другой объект, 
  // для описания конфигурации: 
  myConfig: {
    useCaching: true,
    language: 'en'
  },

  // Очень простой метод
  myMethod: function() {
    console.log('I can haz functionality?');
  },

  // вывод значения заданного в конфигурации 
  myMethod2: function() {
    console.log('Caching is: ' + ((this.myConfig.useCaching) ? 'enabled' : 'disabled'));
  },

  // переопределение конфигурации
  myMethod3: function(newConfig) {
    if (typeof newConfig == 'object') {
      this.myConfig = newConfig;
      console.log(this.myConfig.language);
    }
  }
};

myModule.myMethod(); // 'I can haz functionality'
myModule.myMethod2(); // Вывод 'enabled'
myModule.myMethod3({
  language: 'fr',
  useCaching: false
}); // 'fr'

````

## Паттерн «Модуль» (Model)

«Модуль» — это популярная реализация паттерна, инкапсулирующего приватную информацию, состояние и структуру, используя замыкания. Это позволяет оборачивать публичные и приватные методы и переменные в модули, и предотвращать их попадание в глобальный контекст, где они могут конфликтовать с интерфейсами других разработчиков. Паттерн «модуль» возвращает только публичную часть API, оставляя всё остальное доступным только внутри замыканий.

Это хорошее решение для того, чтобы скрыть внутреннюю логику от посторонних глаз и производить всю тяжелую работу исключительно через интерфейс, который вы определите для использования в других частях вашего приложения. Этот паттерн очень похож на немедленно-вызываемые функции (IIFE), за тем исключением, что модуль вместо функции, возвращает объект.

Важно заметить, что в JavaScript нет настоящей приватности. В отличии от некоторых традиционных языков, он не имеет модификаторов доступа. Переменные технически не могут быть объявлены как публичные или приватные, и нам приходится использовать область видимости для того, чтобы эмулировать эту концепцию. Благодаря замыканию, объявленные внутри модуля переменные и методы доступны только изнутри этого модуля. Переменные и методы, объявленные внутри объекта, возвращаемого модулем, будут доступны всем.

Ниже вы можете увидеть корзину покупок, реализованную с помощью паттерна «модуль». Получившийся компонент находится в глобальном объектеbasketModule, и содержит всё, что ему необходимо. Находящийся внутри него, массив basketприватный, и другие части вашего приложения не могут напрямую взаимодействовать с ним. Массивbasket существует внутри замыкания, созданного модулем, и взаимодействовать с ним могут только методы, находящиеся в том же контексте (например,`addItem(), getItem()`).

````javascript 
var basketModule = (function() {
  var basket = []; // приватная переменная return 
  {
    // методы доступные извне 
    addItem: function(values) {
      basket.push(values);
    },
    getItemCount: function() {
      return basket.length;
    },
    getTotal: function() {
      var q = this.getItemCount(),
        p = 0;
      while (q--) {
        p += basket[q].price;
      }
      return p;
    }
  }
}());
````

Внутри модуля, как вы заметили, мы возвращаем объект. Этот объект автоматически присваивается переменнойbasketModule, так что с ним можно взаимодействовать следующим образом:
````javascript
// basketModule - это объект со свойствами, которые могут также быть и методами: 
basketModule.addItem({
  item: 'bread',
  price: 0.5
});

basketModule.addItem({
  item: 'butter',
  price: 0.3
});

console.log(basketModule.getItemCount());
console.log(basketModule.getTotal());

// А следующий ниже код работать не будет: 
console.log(basketModule.basket);

// undefined потому что не входит в возвращаемый объект console.log(basket);
// массив доступен только из замыкания
````

Методы выше, фактически, помещены в неймспейсbasketModule.

Исторически, паттерн «модуль» был разработан в 2003 году группой людей, в число которых входил Ричард Корнфорд. Позднее, этот паттерн был популяризован Дугласом Крокфордом в его лекциях, и открыт заново в блоге YUI благодаря Эрику Мирагилиа.

Давайте посмотрим на реализацию «модуля» в различных библиотеках и фреймворках.

Dojo

Dojo старается обеспечивать поведение похожее на классы с помощью dojo.declare, который, кроме создания «модулей», также используется и для других вещей. Давайте попробуем, для примера, определить basket как модуль внутри неймспейса store:
`````javascript
// традиционный способ
var store = window.store || {};
store.basket = store.basket || {};
// с помощью
dojo.setObject dojo.setObject("store.basket.object", (function() {
  var basket = [];

  function privateMethod() {
    console.log(basket);
  }
  return {
    publicMethod: function() {
      privateMethod();
    }
  };
}()));

`````
Лучшего результата можно добиться, используяdojo.provide и миксины.

YUI

Следующий код, по большей части, основан на примере реализации паттерна «модуль» в фреймворке YUI, разработанным Эриком Миргалиа, но более самодокументирован.
````javascript
YAHOO.store.basket = function() {
  // приватная переменная:
  var myPrivateVar = "Ко мне можно получить доступ только из YAHOO.store.basket.";
  // приватный метод:
  var myPrivateMethod = function() {
    YAHOO.log("Я доступен только при вызове из YAHOO.store.basket");
  }
  return {
    myPublicProperty: "Я - публичное свойство",
    myPublicMethod: function() {
      YAHOO.log("Я - публичный метод");
      // Будучи внутри корзины я могу получить доступ к приватным переменный и методам: 
      YAHOO.log(myPrivateVar);
      YAHOO.log(myPrivateMethod());
      // Родной контекст метода myPublicMethod сохранён
      // поэтому мы имеет доступ к this
      YAHOO.log(this.myPublicProperty);
    }
  };
}();


````

jQuery

Существует множество способов, чтобы представить jQuery-код в виде паттерна «модуль», даже если этот код не напоминает привычные jQuery-плагины. Бен Черри ранее предлагал способ, при котором, если у модулей есть общие черты, то они объявляются через функцию-обертку.

В следующем примере функцияlibrary используется для объявления новой библиотеки и, автоматически, при создании библиотеки (т.е. модуля), связывает вызов метода `init	 сdocument.ready`.
````javascript
function library(module) {
  $(function() {
    if (module.init) {
      module.init();
    }
  });
  return module;
}
var myLibrary = library(function() {
  return {
    init: function() { /* код модуля */ }
  };
}());

````

## Паттерн «Фасад» (View)

Ключевую роль в архитектуре, которую мы обсуждаем в этой книге, играет шаблон проектирования под названием «фасад».

Как правило, фасад используется для создания некоторой абстракции, скрывающей за собой совершенно иную реальность. Паттерн «фасад» обеспечивает удобный высокоуровневый интерфейс для больших блоков кода, скрывая за собой их истинную сложность. Относитесь к фасаду, как к упрощенному API, который вы отдаете в пользование другим разработчикам.

Фасад — структурный паттерн. Часто его можно обнаружить в JavaScript-библиотеках и фреймворках, где пользователям доступнен только фасад — ограниченная абстракция широкого диапазона поведений реализованных внутри.

Благодаря такому подходу, пользователь взаимодействует только с интерфейсом, не имея никакого представления о подсистемах, которые скрываются за ним.

Причина, по которой нам интересен фасад — возможность скрыть детали реализации конкретного функционала, хранящиеся в модулях. Это позволит нам вносить изменения в реализацию, не сообщая об этом пользователям.

Надежный фасад — наш упрощенный интерфейс — позволит нам не беспокоиться о тесных связях некоторых модулей нашей системы с dojo, jQuery, YUI, zepto или какой-либо другой библиотекой. Это становится не так важно. Вы можете переходить с одной библиотеки на другую не меняя слой взаимодействия. К примеру, с jQuery на dojo. Более того, у вас появляется возможность совершить такой переход на более поздних этапах, без изменений в остальных частях системы.

Ниже я написал достаточно простой пример использования фасада. Как вы видите, у нашего модуля есть несколько приватных методов. Чтобы создать более простой интерфейс для доступа к этим методам мы используем фасад.

````javascript
var module = (function() {
  var _private = {
    i: 5,
    get: function() {
      console.log('Текущее значение:' + this.i);
    },
    set: function(val) {
      this.i = val;
    },
    run: function() {
      console.log('процесс запущен');
    },
    jump: function() {
      console.log('резкое изменение');
    }
  };
  return {
    facade: function(args) {
      _private.set(args.val);
      _private.get();
      if (args.run) {
        _private.run();
      }
    }
  }
}());
module.facade({
  run: true,
  val: 10
});
 
// Текущее значение: 10, процесс запущен 
````

Это и есть та причина, по которой мы добавили фасад к нашей архитектуре. В следующей главе мы обсудим медиатор. Принципиальное различие между этими двумя паттернами заключается в том, что фасад, как структурный паттерн, всего лишь передает существующую функциональность в медиатор, в то время как медиатор, как поведенческий паттерн, может эту функциональность расширять.


## Паттерн «Медиатор» (Controller)

Объяснить, что представляет собой паттерн «медиатор» достаточно просто на примере следующей аналогии — представьте себе контроль траффика в аэропорте: все решения о том, какие самолеты могут взлетать или садиться, принимает диспетчер. Для этого, все сообщения, исходящие от самолетов, поступают в башню управления, вместо того, чтобы пересылаться между самолетами напрямую. Такой централизованный контроллер — это и есть ключ к успеху нашей системы. Это и есть «медиатор».

Медиатор применяется в системах, где взаимодействие между модулями может быть весьма сложными, но, в то же время,хорошо определенными. Если вы полагаете, что связи между модулями вашей системы будут постоянно расти и усложняться, то, возможно, вам стоит добавить центральный элемент управления. Паттерн «медиатор» отлично подходит для этой роли.

Медиатор выступает в качестве посредника в общении между различными модулями,инкапсулируя их взаимодействие. Кроме того, этот шаблон проектирования, предотвращая прямое взаимодействие различных компонентов системы, способствует ослаблению связей в коде. В нашей системе он так же помогает в решении проблем, связанных с зависимостями модулей.

Какие еще преимущества существуют у «медиатора»? К примеру, медиатор позволяет каждому модулю функционировать абсолютно независимо от других компонентов системы, что приводит к большей гибкости. Если вам ранее уже приходилось использовать паттерн «наблюдатель» в роли системы доставки событий между различными частями в вашей системе, то вам не составит труда разобраться с медиатором.

Давайте посмотрим на модель взаимодействия модулей и медиатора:

Мы можем рассматривать модули, как «издателей», публикующих события. Медиатор же является и «издателем» и «подписчиком» одновременно. В примере, Module 1 посылает сообщение, предполагающее некоторую реакцию, медиатору. Затем, медиатор, получив сообщение, уведомляет другие модули об определенных действиях, которые необходимо выполнить для завершения задачи. Module 2выполняет необходимые Module 1 действия, и сообщает о результате обратно, в медиатор. В это же время, медиатор запускаетModule 3 для логгирования поступающих сообщений.

Обратите внимание: здесь нет прямого взаимодействия между модулями. Если в Module 3произойдет ошибка или, к примеру, он просто перестанет работать, то медатор, теоретически, может приостановить выполнение задач в других модулях, затем перезапустить Module 3 и продолжить работу, практически не влияя на работу всей системы. Такая слабая связанность модулей является одним из самых сильных преимуществ паттерна «медиатор», который я вам предлагаю использовать.

Посмотрим на его преимущества:

Уменьшает связывание модулей, добавляя посредника — центральный элемент управления. Это позволяет модулям отправлять и слушать сообщения, не затрагивая остальной части системы. Сообщения могут быть обработаны любым количеством модулей сразу.

Благодаря слабой связанности кода, внедрение новой функциональности происходит существенно легче.

И недостатки:

Модули больше не могут взаимодействовать напрямую. Использование медиатора приводит к небольшому падению производительности — такова природа слабой связанности — становится достаточно трудно определить реакцию системы, отталкиваясь только от событий, происходящих в ней.

В конце дня, системы с высокой связанностью кода могут вызывать различные головные боли. Часто решением этих проблем заключается в уменьшении связанности.

Пример: одна из возможных реализаций паттерна «медиатор», основанная на работе` @rpflorence`

````javascript
var mediator = (function() {
  var subscribe = function(channel, fn) {
      if (!mediator.channels[channel]) mediator.channels[channel] = [];
      mediator.channels[channel].push({
        context: this,
        callback: fn
      });
      return this;
    },
    publish = function(channel) {
      if (!mediator.channels[channel]) return false;
      var args = Array.prototype.slice.call(arguments, 1);
      for (var i = 0, l = mediator.channels[channel].length; i < l; i++) {
        var subscription = mediator.channels[channel][i];
        subscription.callback.apply(subscription.context, args);
      }
      return this;
    };
  return {
    channels: {},
    publish: publish,
    subscribe: subscribe,
    installTo: function(obj) {
      obj.subscribe = subscribe;
      obj.publish = publish;
    }
  };
}());

````
И два примера использования реализации, написанной выше:
````javascript
//Pub/sub on a centralized mediator 
mediator.name = "tim";
mediator.subscribe('nameChange', function(arg) {
  console.log(this.name);
  this.name = arg;
  console.log(this.name);
});
mediator.publish('nameChange', 'david'); //tim, david //Pub/sub via third party mediator
var obj = {
  name: 'sam'
};
mediator.installTo(obj);
obj.subscribe('nameChange', function(arg) {
  console.log(this.name);
  this.name = arg;
  console.log(this.name);
});
obj.publish('nameChange', 'john'); //sam, john

````

## Ссылки по теме
